---
title: 'Homework 6: working with stringr and nested lists'
author: "Emily West"
date: "11/5/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
library(glue)
```

Dear Reveiwer,
Welcome to my first STAT 547A homework! I am new to the course, having taken Jenny Bryan's STAT 545 last fall so please bear with me as I warm up some out-of-shape coding muscles. Considering I return to my 545 homework assignments fairly regularly to check specific code and functions I hope to format these homework assignments in much the same way, filled with lots of comments about what works, why it works, and of course what doesn't work and potential reasons for why that is. 
For the first part of this homework adventure I opted to work through the exercises in the strings chapter of R for data science.
```{r}
#Some background on regular expressions: a regular expression is simply a pattern describing a string of characters. A regular expression is used to match 0-n characters in a string. A regular expression can include digits and letters which will match to themselves. Metacharacters are characters with special meaning including \ $ . [ { etc, to match a metacharacter it must be preceded with a backslash.

############14.2.5#####################
#1. paste() is a concatenate function that binds together character strings. You can designate a desired seperate function, such as sep = "," or sep = ".", however the default is sep = " ". The paste0() is similar in its function but instead the default seperation is sep = "", making it more efficient. glue() is a stringr function that is similar to base R's paste(). paste() will return NA's if they are present in tbe vector

x<-c("abc","ab",NA)
y<-c("xyz", "yz", "z")

paste(x,y) #space is default seperator, NA is returned
(paste0(x,y)) #space is dropped, NA still returned
(glue("{x}{y}")) #no spaces, NA still returned

#2. If you were using str_c to develop a matrix of strings, the sep = would designate the string to be placed between each column, whereas collapse designates whether or not each row is collapse into a single string or the entire matrix collapsed into a string. collapse = NULL means that each row is a string, collapse = non-NUll, the entire matrix is a single string.
str_c(y, sep = ".", collapse = NULL) # there are still 3 strings of lengths 3,2,1
str_c(y, sep = ".", collapse = ",") # now we have one string of a length 8

#3. Extract the middle character from a string using str_subset() and str_length(): 
#Note: str_sub(argument, character location to start, character location to end)
  #first, with a string that is an odd length:
q<-c("abcde")
q
(str_length(q)) #this string is 5 characters long
str_sub(q,3,3) #the third entry is the middle entry

x<- "abcd"
(str_length(x)) #tricky, now there is a string with an even number of characters!
str_length(x)/2
str_sub(x, 2,3) #now I have selected for the 2 middle characters

#4. str_wrap() is a formatting function that formats strings into paragraphs that are designated by the input paramaters
y <- "R is a challenging language for some of us to learn, however it is proving to be an invaluable tool in expediating and tracking analyses related to my thesis"
str_wrap(y, width = 25, indent = 2) #yikes, this is ugly - \n is showing the placement of each paragraph, 25 indicates that as close to 25 characters should be printed per line 
cat(str_wrap(y, width = 25)) #cat() is a nice way to print the output of the str_wrap to visually check the formatting

#5. str_trim() "trims" the whitespace from the beginning and end of a character string:
a <- c(" a ", " b ", " a b ")
str_trim(a) #trims the leading and tailing white space but maintains spaces in between characters

#6. Write a function that turns a vector into a string, consider what it should do if a vector length 0,1,2 is input

c<-c("a", "b", "c")
d<-c("a","b")
str_length(c) #3 strings with a length of 1

to_str<-function(x){
   if(length(x)<3) {
     stop('I am so sorry, but this function only works for vectoris greater than 3 characters')} #vector must have a length longer than 3, again the 
  str_c(x, collapse = "")
  }

#to_str(d) #function fails on a vector with a length shorter than 3!
str_length(to_str(c)) # a single string with a length of 3


############14.3.1#####################
#Matching is all about indicating and locating a character, or set of characters, you are interested in.
#examples from the text:
x <- c("apple", "banana", "pear")
str_view(x, "an") #in x highlight characters a and n, based on the the output from banana and apple, this suggests str_view will not return redundant strings, that is it only highlights the first "p" in apple and the first instance of "an" in banana 

str_view(x, ".a.") #"." before and after a character has a special behavior that matches any character around the character you indicate. If you actually want to match a "." you have to escape it using a backslash

#1.Explain why each of these strings don’t match a \: "\", "\\", "\\\".
  #A backslash is a extra special character because it has two functions, one used to create regular expressions and the other to escape other special characters like ".", "'"
  # This is best expressed with a couple of examples, note the original code is from the R for Data Science example, however I have modifided and expanded it to make expressly clear what is happening in each step.
str_view(c("abc", "a.c", "bef"), "a.c")#returns a and c with ANY character in between the two
str_view(c("abc", "a.c", "bef"), "a\\.c") #returns a.c literally, that is, "." is not being used in its special way of matching any character it is being used as a character itself
str_view(c("abc", "a.c", "bef"), "\\.") #returns . as its own character
# str_view(c("abc", "a\c", "bef"), "\\\\") #Yikes, that won't work because R is looking for a special character to escape after the \
str_view(c("abc", "a\\c", "bef"), "\\\\") # in the string itself we need a \ to escape the backslash and in the parameter we need the double backslash to match the special character \ that is being escaped in the first place.

#2.How would you match the sequence "'\? 
  #This requires escaping a string of special characters, which means everyone gets their own backslash:
str_view(c("\"\'\\"), "\\'\\\\") #something funny is happening, the quotes are being closed so they are not being matched- I tried several iterations of adding backslashes before the " but to no avail :(
str_view(c("\'\\"), "\\'\\\\") #I can get the last two characters to be matched

#3. What patterns will the regular expression \..\..\.. match? How would you represent it as a string?
c<- "\asdfghjkl"

#str_view(c, "\..\..\..") # str_view does not seem to like this type of expression because of the \. which is it designating an "unrecognized escape character"
c<- "what if i.write a sentence.with lots of periods.init"
#str_view(c, "\..\..\..") #hmmm the way I read the expression is: escape the "." and match any character after it, but that does not appear so. 
#c<- "what if i\.write a sentence\.with lots of periods.init"
#str_view(c, "\\..\\..\\..") #NOPE

############14.3.2#####################
#Special "anchors": ^ matches the start of a string, $ matches the end of a string
#Hadley Wickham remembers it this way: "To remember which is which, try this mnemonic which I learned from Evan Misshula: if you begin with power (^), you end up with money ($)."

#1. How would you match the literal string "$^$"?
str_view(c("$^$"), "\\$\\^\\$") #escape and match all special characters using \\

#2. Given the corpus of common words in stringr::words, create regular expressions that find all words that:
  # First, what are we dealing with in stringr::words? View(stringr::words), wow 980 words!

# a. Start with y:
str_view(stringr::words, "^y", match = TRUE)
# b. End with x:
str_view(stringr::words, "x$", match = TRUE)
str_subset(stringr::words, "x$") #something funky is happening in my viewer and I can't scroll so this is a check to see if the code actually work and it looks like it does!

#3. Are exactly three letters long. (Don’t cheat by using str_length()!)
#str_view(stringr::words, "^...") #gives you the first 3 letters of each word
str_view(stringr::words, "\\b[a-zA-Z0-9]{3,3}\\b", match = TRUE)# SWEET, using the boundary "\b" expression you designate what you want selected, here it is alpha numeric, then {min,max} length of words

#4. Have seven letters or more
str_view(stringr::words, ".......", match = TRUE) #Match = true resolves earlier issue, it highlights in the viewer only the matches

############14.3.3#####################

#1. Create regular expressions to find all words that

  #a. starts with a vowel:
str_view(stringr::words, "^a|^e|^i|^o|^u", match = TRUE) #the | indicates "or" between each matching option, early attemps show that you must have ^ for each vowel, that is you must designate position after every or otherwise it will pick any ol' word with an e,i,o,u
 #b. only contain consonants
str_view(stringr::words, "!a|!e|!i|!o|!u", match = TRUE) #it does not appear there are any all consonant words

  #c. end with ed, but not eed
str_view(stringr::words, "ed$", match = TRUE) #grabs all that end in -ed AND eed, but how to get rid of those eed?
########str_view(stringr::words, "\\b[a-zA-Z0-9]{3,3}\\bed$", match = TRUE)
#str_view(stringr::words, "["ed$"]", match = TRUE) #I have struggled through several iterations of modifying this approach :(

  #d. ending with -ing or -ise
str_view(stringr::words, "ing$|ise", match = TRUE)

#2. Empirically verify the rule "i before e except after c"
str_view(stringr::words, "cei", match = TRUE)

#3. Is "q" always followed by "u"? 
  #Yes.
str_view(stringr::words, "qu", match = TRUE) # there are 10 occurences where q comes directly before u
str_view(stringr::words, "q.u", match = TRUE) # there are no occurence where q is seperated by some character then followed by u
str_view(stringr::words, "uq", match = TRUE) #no occurences where u is directly before q
str_view(stringr::words, "u.q", match = TRUE) 

#4. Write a regular expression that matches a word if its probably written in British English, not American English:

str_view(stringr::words, "..our$", match = TRUE) #the ... gets rid of any 4 and 5 letter words that are ubiquitous to both American and British english like four and flour

#5. Create a regular expression that will match telephone numbers as commonly written in your country
c<- c("555-555-5555", "home 555-555-5551", "mobile555-555-5552")

str_view(c, "...\\-...\\-....") 
str_subset(c, "...\\-...\\-....") # we could subset all the strings with a phone number


############14.3.4#####################
#1. Describe the equivalents of ?, +, *, in {m,n} form.
  #Take R for data science's example:
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "C{1,2}")
  #? picks up the repition at the minimum length, that is {1,2}
str_view(x, "CC+")
str_view(x, "CC{1,3}")
  # + picks up all repeated characters starting with a length of 1 and will match all repetitions to n equivalent to {1,n}
str_view(x, "MD*") # * will pick up character strings even if the repition is 0
str_view(x, "MD{0,1}")

#2. a. ^.*$ - I'm totally baffled by this string...^indicates the beginning anchor, $ is the ending anchor, . expresses any character, and * highlights repetition of 0 or more times... none of the characters have been escaped


  #b. "\\{.+\\}" This is an equally confusing expression. match any character that repeats more than once?
str_view(x, "\\{.+\\}")
  
  #c. \d{4}-\d{2}-\d{2} This expression matches a string that starts with 4 digits, is seperated by - followed by two digits, another - and lastly 2 more digits
y<- c("home 1234-12-12")
str_view(y, "\\d{4}-\\d{2}-\\d{2}")
  
#d. "\\\\{4}" This expression escapes the \ and give the proceeding characters, was there maybe a \d that was supposed to be in here?
z<- c("\\123456")
z<- c("\\ancsdfs")
str_view(z, "\\\\{4}")

#3. Create regular expressions to find all words that:
  #a.start with three consonants 
str_view(words, "^[^aeiou]{3,3}", match = TRUE)

  #b. have three or more vowels in a row
     str_view(stringr::words, "[aeiou]{3,3}", match = TRUE) #nope this gives you all words that have at least one of those vowels, not in a row
   #c. Have 2 or more vowel-consonant pairs in a row
     
#4. I spent an abusrd amount of time trying to do the regex crossword to no avail :(
     
#############14.3.5################
#1. describe what the expression below will match:
     #a. (.)\1\1
     c<-c("aaaaabbbbcccbcbcbcb", "a", "b") 
str_view(c, "(.)\\1\\1") #it matches the first group "aaa"
  #b. "(.)(.)\\2\\1"
str_view(c, "(.)(.)\\2\\1") #it matches the first group "aaaa"
  #c. (..)\1
str_view(c, "(..)\\1") #same result as "(.)(.)\\2\\1", 2 characters repeated once 
  #d. "(.).\\1.\\1"
str_view(c, "(.).\\1.\\1") #same result as last 2 expressions
  #e. "(.)(.)(.).*\\3\\2\\1"
str_view(c, "(.)(.)(.).*\\3\\2\\1") # I actually have no idea what this expression is saying, other than the fact it pulls out the repetition of "cbcbcbc", maybe (.)(.)(.) refers to the 3 characters, . refers to the middle character b and * wants the repetition of that sequence, however I am still unsure what the heck the \\3\\2\1 are referring to

#2. Construct regular expressions to match words that:
  #a. start and end with the same character
c<- c("bulb","toast", "noun")
str_view(c, "^(.)(.)$\\1") #well that doesn't work
  #b. Contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice.)
r<-c("church", "fright")
#str_view(r, "(..)\\2")
#str_view(r, "(..)\\1")
str_view(r, "(..)") #that just gets the first two letters...but how do we move on to matching repitition
#str_view(r, "(..)\\1") #nope
#str_view(r, "(..)*\\6")
  #c. Contain one letter repeated in at least three places (e.g. “eleven” contains three “e”s.) 

x<- c("bananana", "cococonutcoco", "cucucumber")
#str_view(x, "(..)\\1")

#############14.4.2################
#Life is often easier if you build a series of simple regexps rather than one big monolith
#str_detect() #let's you suss out patterns and will return a logical vector of the same length as the input. by converting the output object to numeric the TRUEs and FALSEs become binary and you can use sum() and mean()
mean(str_detect(words, "[aeiou]$")) #words that end with a vowel
no_vowels_1 <- !str_detect(words, "[aeiou]")# all the words that don't have at least 1 vowel

#1.For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls
  #a. Find all words that start or end with x.
str_detect(words, "x$") #this gives you a logical output of TRUEs and FALSEs
str_view_all(words, "x$", match = TRUE) #this shows you the actual words that end with x
str_view_all(words, "^x", match = TRUE) #no words begin with x
#another way to write this:
  words[str_detect(words, "x$")]
  str_subset(words, "x$")
  #b. Find all words that start with a vowel and end with a consonant
str_detect(words, "^[aeiou][^aeiou]$")
  str_view_all(words, "^[aeiou][^aeiou]$", match = TRUE) #unfortunately this only gives youthe two letter words that start with a vowel and end with a consonant
  
  #c. Are there any words that contain at least one of each different vowel? Probably


#2. What word has the highest number of vowels? What word has the highest proportion of vowels? (Hint: what is the denominator?)
  df<- tibble(word = words, i = seq_along(word))
#df %>% mutate(vowels = str_count(word, "[aeiou]"),consonants = str_count(word, "[^aeiou]"))
#df %>% select("word", "consonants") %>% summary(max) #this should work if it were being read as a dataframe with columns for vowels and consonants, however it is not so its not working...either.


#############14.4.3################
#1. In the previous example, you might have noticed that the regular expression matched “flickered”, fix the code:

colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match

more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)

#2. From the Harvard sentences data, extract:

  #a. The first word from each sentence.
  #b. All words ending in ing.
str_extract(sentences, "ing$") #this doesn't apear to do anything
  #c. All plurals.
# to do this I would need to find all of the words in each sentence that end with s

#############14.4.4################

#1. Find all words that come after a “number” like “one”, “two”, “three” etc. Pull out both the number and the word.
num<- "(one|two|three|four) ([^ ]+)"
is_num <- sentences %>%  str_subset(num)
is_num %>% str_extract(num)

#2. Find all contractions. Separate out the pieces before and after the apostrophe. 
con <- "(can't|won't|isn't|shouldn't|wouldn't|couldn't|hasn't)" #identify the contractions
is_con <- sentences %>% str_subset(con)
is_con %>% str_extract(con) 
#getting a return of character (0)?

c<- "(.'.)"
is_c<- sentences %>% str_subset(c) 
is_c %>% str_extract(c) #this only gives you the letters before and after the apostrophe
c<- "(.......'.)"
is_c<- sentences %>% str_subset(c) 
is_c %>% str_extract(c) # this is a cheap work around to the above mentioned problem

#############14.4.5################
#1. Replace all forward slashes in a string with backslashes.
x<- c("f/x/asd/")
#str_replace(x, c("/"="\\\\"))

#2. Implement a simple version of str_to_lower() using replace_all().
c<- c("the quick brown fox","jumped over the lazy dog")
str_replace_all(c, c("a" = "A", "b" = "B"))

#3. Switch the first and last letters in words. Which of those strings are still words?
sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") #this is how the r gods switched word placement around

str_replace(words, "(.) (.) (.)", "\\1 \\3 \\2")



#############14.4.6################
#1. Split up a string like "apples, pears, and bananas" into individual components.
c<- ("apples pears bananas")
str_split(c, " ", simplify =TRUE)

#2. Why is it better to split up by boundary("word") than " "?
#by splitting using a word/boundary you are being more specific to what the output object will be.

#3. What does splitting with an empty string ("") do? Experiment, and then read the documentation
str_split(c, "", simplify =TRUE)
#Splitting with an empty string gives you ever character, including spaces, that exist in the string

#############14.5.1################
#1. How would you find all strings containing \ with regex() vs. with fixed()?

#2. What are the five most common words in sentences?

#############14.7.1 ################

#1. Find the stringi functions that:

#2. Count the number of words.
#a. Find duplicated strings.
#b. Generate random text.
#c. How do you control the language that stri_sort() uses for sorting?

```


#Part I reflection:
This exercise took me many hours to complete and many of the problems I attempted I have no resolution despite trolling the internet for solutions. I find much of the matching syntax to be not very intuitive, especially with \\ and ordering and spent A LOT of time trying to figure that out alone. 
A great resource I found:
http://www2.stat.duke.edu/~cr173/Sta523_Fa15/regex.html

##PART 2
Create a function using the gapminder data
```{r}
#library(tidyverse)
#install.packages("gapminder")
library(gapminder)
#First, explore what we're working with in the data:
gap<-gapminder
str(gap) #6 variables, 1704 observations

gap %>% filter(country =="Canada") 

panel <-gap %>% filter(country =="Canada") %>% select(country, lifeExp, pop) #data is grouped by year for canada, we have mean life expectancy and mean population
lm(panel$lifeExp~panel$pop)

#This type function will be important for my own analysis were I will be plugging different data in constantly and not wanting to rewrite the skeleton code:


model_funs<- function(x,y){
  pain<-gap %>% filter(country == y) %>% select(country, lifeExp, pop)
  lmodel<-lm(pain$lifeExp~panel$pop)
  print(lmodel)
  lm.sum<-summary(lmodel)
  print(lm.sum)
} #It would be really nice to stop this code, or get a warning if the model was not significant, that is the p-Value was greater than 0.05

model_funs(gap, "Algeria")

#Oh no! What if the data doesn't appear linear? Easy, plop those transformations right into the code!
model_nln<- function(x,y){
  pain<-gap %>% filter(country == y) %>% select(country, lifeExp, pop)
  lmodel<-lm(pain$lifeExp~(panel$pop^2))
  print(lmodel)
  lm.sum<-summary(lmodel)
  print(lm.sum)
}

model_nln(gap, "Algeria")

```
#Part II reflection:
WOw this part was SO much more enjoyable! Functions, while intimidating, are an excellent way to streamline a task, for instance when trying to fit linear models. I can use this type of function quite readily to determine 1. if my models are significant and 2. which variables are significant. As I continue to develop my skills I would like to be able to implement a warning that one or both of these things are false. The skeleton code that I created above can easily be changed to accomodate different, or additional, variables. It also makes performing transformations quite seamless. 
